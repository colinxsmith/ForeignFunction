/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.bitaplus.BitaModel.Optimisation;

public class OptimiserController {

	static
	{
		try {System.loadLibrary("OptimiserController");} 
		catch (UnsatisfiedLinkError e)
		{
			System.err.println("Native code library OptimiserController failed to load.\n" + e);
			System.err.println("Native code library OptimiserController failed to load.\n" + e);
			System.err.println("Native code library OptimiserController failed to load.\n" + e);
			System.err.println("Native code library OptimiserController failed to load.\n" + e);
			System.err.println("Native code library OptimiserController failed to load.\n" + e);
			System.err.println("Native code library OptimiserController failed to load.\n" + e);
	//		System.exit(1);
		}
	}
	public static double[][] Allocate2D(int n,int m)
	{
		double [][] y=new double[n][m];
		return y;
	}
	public static double[][] single2double(int n,int m,double[]x)
	{
	//To tranform the constraints from list to 2d-array do A=single2double(m,n,A) in jython
		int i,j;
		double [][] y=new double[n][m];
		for(i=0;i<n;++i)
		{
			for(j=0;j<m;++j)
			{
				y[i][j]=x[i+n*j];
			}
		}
		return y;
	}
	public static String[] [] Convert(String[][]y)
	{
		return y;
	}
	public static double[] [] Convert(double[][]y)
	{
		return y;
	}
	public static long[] [] Convert(long[][]y)
	{
		return y;
	}
	public static int[] [] Convert(int[][]y)
	{
		return y;
	}
	public static double[] Convert(double[]y)
	{
		return y;
	}
	public static long[] Convert(long[]y)
	{
		return y;
	}
	public static int[] Convert(int[]y)
	{
		return y;
	}
	public static String[] Convert(String[]y)
	{
		return y;
	}

  public static void MCAR(long n, long nf, double[] w, double[] alpha, double[] FL, double[] SV, double[] FC, double[] MC) {
    OptimiserControllerJNI.MCAR(n, nf, w, alpha, FL, SV, FC, MC);
  }

  public static void FX_get(long n, long nf, double[] w, double[] FL, double[] SV, double[] FC, double[] FX) {
    OptimiserControllerJNI.FX_get(n, nf, w, FL, SV, FC, FX);
  }

  public static short SimpleOpt(long n, int nfac, int ls, int full, double[] SV, double[] FL, double[] FC, double[] w, long m, double[] L, double[] U, double[] A, double[] alpha, double gamma, double[] ogamma, double minRisk, double maxRisk, double five, double ten, double forty, String[] names) {
    return OptimiserControllerJNI.SimpleOpt(n, nfac, ls, full, SV, FL, FC, w, m, L, U, A, alpha, gamma, ogamma, minRisk, maxRisk, five, ten, forty, names);
  }

  public static void testchars(int n, String[] in, String[] out) {
    OptimiserControllerJNI.testchars(n, in, out);
  }

  public static void test2dlist(long n, long m, double[][] TWOD) {
    OptimiserControllerJNI.test2dlist(n, m, TWOD);
  }

  public static void Sym_multT(long n, double[] S, double[] x, double[] w_opt) {
    OptimiserControllerJNI.Sym_multT(n, S, x, w_opt);
  }

  public static void Sym_mult(long n, double[] S, double[] x, double[] w_opt) {
    OptimiserControllerJNI.Sym_mult(n, S, x, w_opt);
  }

  public static double ddot(long n1, double[] a1, long ia, double[] x1, long ix, long astart, long xstart) {
    return OptimiserControllerJNI.ddot(n1, a1, ia, x1, ix, astart, xstart);
  }

  public static void GetOrder(long n, double[] a, long[] bb1, int abs, byte[] bad) {
    OptimiserControllerJNI.GetOrder(n, a, bb1, abs, bad);
  }

  public static void PatternMin(long n, double[] w_opt, double[] step, double[] ynewlow, double scale, Object calcfx, short iprint, long maxit, short icon) {
    OptimiserControllerJNI.PatternMin(n, w_opt, step, ynewlow, scale, calcfx, iprint, maxit, icon);
  }

  public static void dumpvec(long n, String name, double[] A, String file) {
    OptimiserControllerJNI.dumpvec(n, name, A, file);
  }

  public static void dumpsvec(long n, String name, String[] A, String file) {
    OptimiserControllerJNI.dumpsvec(n, name, A, file);
  }

  public static void ReorderS(long n, long[] order, double[] QFIX) {
    OptimiserControllerJNI.ReorderS(n, order, QFIX);
  }

  public static void ReorderSquare(long n, long[] order, double[] QFIX) {
    OptimiserControllerJNI.ReorderSquare(n, order, QFIX);
  }

  public static void Reorder(long n, long[] order, double[] QFIX) {
    OptimiserControllerJNI.Reorder(n, order, QFIX);
  }

  public static void Reorder_mult(long n, long[] order, double[] QFIX, long m) {
    OptimiserControllerJNI.Reorder_mult(n, order, QFIX, m);
  }

  public static void getBIMcov(String factorfile, String covfile, long[] BIMnf, String[] factors, double[] QFIX) {
    OptimiserControllerJNI.getBIMcov(factorfile, covfile, BIMnf, factors, QFIX);
  }

  public static void procBIMcov(String factorfile, String covfile, String outfile) {
    OptimiserControllerJNI.procBIMcov(factorfile, covfile, outfile);
  }

  public static void procBIMmod(String modelfile, String facretfile, String expfile, String svfile, String outfile) {
    OptimiserControllerJNI.procBIMmod(modelfile, facretfile, expfile, svfile, outfile);
  }

  public static void digitise(long n, double[] w, double[] initial, double[] minlot, double[] sizelot, double[] digit) {
    OptimiserControllerJNI.digitise(n, w, initial, minlot, sizelot, digit);
  }

  public static long roundcount(long n, double[] w, double[] initial, double[] minl, double[] sizl, double[] trw, double[] naive) {
    return OptimiserControllerJNI.roundcount(n, w, initial, minl, sizl, trw, naive);
  }

  public static int fix_covariancem(long n, double[] QFIX) {
    return OptimiserControllerJNI.fix_covariancem(n, QFIX);
  }

  public static short InvQ_d(long n, double[] Q, double[] d, double[] Qm1d) {
    return OptimiserControllerJNI.InvQ_d(n, Q, d, Qm1d);
  }

  public static short ConstrRegress(long n, long m, double[] Q, double[] d, double[] w_opt, double[] L, double[] U, double[][] AAA) {
    return OptimiserControllerJNI.ConstrRegress(n, m, Q, d, w_opt, L, U, AAA);
  }

  public static int pickout(long nstocks, String[] stocklist, long M_nstocks, String[] M_stocklist, double[] QFIX, long[] Order) {
    return OptimiserControllerJNI.pickout(nstocks, stocklist, M_nstocks, M_stocklist, QFIX, Order);
  }

  public static int pickoutstrings(long nstocks, String[] stocklist, long M_nstocks, String[] M_stocklist, String[] Q, long[] Order) {
    return OptimiserControllerJNI.pickoutstrings(nstocks, stocklist, M_nstocks, M_stocklist, Q, Order);
  }

  public static String Return_Message(int ifail) {
    return OptimiserControllerJNI.Return_Message(ifail);
  }

  public static String MultiStageMessage(int ifail) {
    return OptimiserControllerJNI.MultiStageMessage(ifail);
  }

  public static String SOCPlstestMessage(int ifail) {
    return OptimiserControllerJNI.SOCPlstestMessage(ifail);
  }

  public static short eigendecomp(long n, double[] eigvec, double[] eigval, long itmax) {
    return OptimiserControllerJNI.eigendecomp(n, eigvec, eigval, itmax);
  }

  public static void dldlfactNULL(long n, double[] S) {
    OptimiserControllerJNI.dldlfactNULL(n, S);
  }

  public static String expire_date() {
    return OptimiserControllerJNI.expire_date();
  }

  public static String version() {
    return OptimiserControllerJNI.version();
  }

  public static String cversion() {
    return OptimiserControllerJNI.cversion();
  }

  public static String component_key() {
    return OptimiserControllerJNI.component_key();
  }

  public static int days_left(String[] aversion) {
    return OptimiserControllerJNI.days_left(aversion);
  }

  public static void Extract_Factor_Information(long nstocks, long numfac, long Mnstocks, double[][] FLOAD, double[] SSV, String[] stocklist, double[][] MFLOAD, double[] MSV, String[] Mstocklist) {
    OptimiserControllerJNI.Extract_Factor_Information(nstocks, numfac, Mnstocks, FLOAD, SSV, stocklist, MFLOAD, MSV, Mstocklist);
  }

  public static void CurrencyProcessFL(long nf, long n, double[] FL, double[] psi, double[] FLn) {
    OptimiserControllerJNI.CurrencyProcessFL(nf, n, FL, psi, FLn);
  }

  public static void winsorise(long noOfPts, double[] values, int winsorOption, double scaling, double[] returnArray) {
    OptimiserControllerJNI.winsorise(noOfPts, values, winsorOption, scaling, returnArray);
  }

  public static double percentile(long noOfPts, double[] values, int num) {
    return OptimiserControllerJNI.percentile(noOfPts, values, num);
  }

  public static double average(long s, double[] xx) {
    return OptimiserControllerJNI.average(s, xx);
  }

  public static double stddev(long s, double[] xx) {
    return OptimiserControllerJNI.stddev(s, xx);
  }

  public static double covariance1(double[] xx, double[] y, double[] w, long s) {
    return OptimiserControllerJNI.covariance1(xx, y, w, s);
  }

  public static void mAve(long noOfPts, double[] values, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mAve(noOfPts, values, window, ignoreMissing, returnArray);
  }

  public static void mSum(long noOfPts, double[] values, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mSum(noOfPts, values, window, ignoreMissing, returnArray);
  }

  public static void mProd(long noOfPts, double[] values, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mProd(noOfPts, values, window, ignoreMissing, returnArray);
  }

  public static void mCovar(long noOfPts, double[] values1, double[] values2, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mCovar(noOfPts, values1, values2, window, ignoreMissing, returnArray);
  }

  public static void mCorrel(long noOfPts, double[] values1, double[] values2, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mCorrel(noOfPts, values1, values2, window, ignoreMissing, returnArray);
  }

  public static void mVar(long noOfPts, double[] values, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mVar(noOfPts, values, window, ignoreMissing, returnArray);
  }

  public static void mStddev(long noOfPts, double[] values, long window, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.mStddev(noOfPts, values, window, ignoreMissing, returnArray);
  }

  public static void cAve(long noOfPts, double[] values, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cAve(noOfPts, values, ignoreMissing, returnArray);
  }

  public static void cSum(long noOfPts, double[] values, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cSum(noOfPts, values, ignoreMissing, returnArray);
  }

  public static void cProd(long noOfPts, double[] values, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cProd(noOfPts, values, ignoreMissing, returnArray);
  }

  public static void cCovar(long noOfPts, double[] values1, double[] values2, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cCovar(noOfPts, values1, values2, ignoreMissing, returnArray);
  }

  public static void cCorrel(long noOfPts, double[] values1, double[] values2, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cCorrel(noOfPts, values1, values2, ignoreMissing, returnArray);
  }

  public static void cVar(long noOfPts, double[] values, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cVar(noOfPts, values, ignoreMissing, returnArray);
  }

  public static void fake_ETL_data(long n, long tlen, double[] w, double[] DATA, double[] fakeDATA, int plus) {
    OptimiserControllerJNI.fake_ETL_data(n, tlen, w, DATA, fakeDATA, plus);
  }

  public static void VARproperties(long n, long number_included, long tlen, double[] w, double[] DATA, double[] ETL, double[] VAR, double[] ETLbreakdown, double[] etl_per_asset, double[] VARbreakdown, double[] var_per_asset) {
    OptimiserControllerJNI.VARproperties(n, number_included, tlen, w, DATA, ETL, VAR, ETLbreakdown, etl_per_asset, VARbreakdown, var_per_asset);
  }

  public static void cStddev(long noOfPts, double[] values, long ignoreMissing, double[] returnArray) {
    OptimiserControllerJNI.cStddev(noOfPts, values, ignoreMissing, returnArray);
  }

  public static void prodArrays(long noOfPts, double[] values1, double[] values2, double[] returnArray) {
    OptimiserControllerJNI.prodArrays(noOfPts, values1, values2, returnArray);
  }

  public static double wAve(long noOfPts, double[] values, double[] weights) {
    return OptimiserControllerJNI.wAve(noOfPts, values, weights);
  }

  public static double wAveProd(long noOfPts, double[] values1, double[] values2, double[] weights) {
    return OptimiserControllerJNI.wAveProd(noOfPts, values1, values2, weights);
  }

  public static double wCovar(long noOfPts, double[] values1, double[] values2, double[] weights) {
    return OptimiserControllerJNI.wCovar(noOfPts, values1, values2, weights);
  }

  public static double BITA_ddot(long n1, double[] a1, int m1, double[] b1, int m2) {
    return OptimiserControllerJNI.BITA_ddot(n1, a1, m1, b1, m2);
  }

  public static double ddotvec(long n, double[] a, double[] b) {
    return OptimiserControllerJNI.ddotvec(n, a, b);
  }

  public static void genmult(long nl, long ng, double[][] YY, double[][] SSS, double[][] YS) {
    OptimiserControllerJNI.genmult(nl, ng, YY, SSS, YS);
  }

  public static void getFSF(long n, long m, double[] S, double[][] YS, double[] FSF) {
    OptimiserControllerJNI.getFSF(n, m, S, YS, FSF);
  }

  public static double DOT(long n, double[] a, double[] b) {
    return OptimiserControllerJNI.DOT(n, a, b);
  }

  public static void combineS(long n, double[] q, double[] g, double[] U) {
    OptimiserControllerJNI.combineS(n, q, g, U);
  }

  public static void symm_inverse_x(long n, double[] Q, double[] x, double[] Qm1x) {
    OptimiserControllerJNI.symm_inverse_x(n, Q, x, Qm1x);
  }

  public static void vec2symm(long n, double[] vec, double[] symm) {
    OptimiserControllerJNI.vec2symm(n, vec, symm);
  }

  public static void symmsymm(long n, double[] S1, double[] S2, double[] S1S2) {
    OptimiserControllerJNI.symmsymm(n, S1, S2, S1S2);
  }

  public static void Sinv_X(long n, double[] S, double[] X, double[] SiX) {
    OptimiserControllerJNI.Sinv_X(n, S, X, SiX);
  }

  public static double A1MA2(long n, double[] A1, double[] A2, double[] M) {
    return OptimiserControllerJNI.A1MA2(n, A1, A2, M);
  }

  public static void square2symm(long n, double[] S) {
    OptimiserControllerJNI.square2symm(n, S);
  }

  public static void square2sqsymm(long n, double[] S) {
    OptimiserControllerJNI.square2sqsymm(n, S);
  }

  public static void gensymm(long n, double[] M, double[] S, double[] MS) {
    OptimiserControllerJNI.gensymm(n, M, S, MS);
  }

  public static void Sinv_M(long n, double[] S, double[] M) {
    OptimiserControllerJNI.Sinv_M(n, S, M);
  }

  public static double AdotSiAX(long n, double[] Ai, double[] S, double[] Aj, double[] X) {
    return OptimiserControllerJNI.AdotSiAX(n, Ai, S, Aj, X);
  }

  public static double AdotSi(long n, double[] A, double[] S) {
    return OptimiserControllerJNI.AdotSi(n, A, S);
  }

  public static void SiAX(long n, double[] S, double[] A, double[] X, double[] SAX) {
    OptimiserControllerJNI.SiAX(n, S, A, X, SAX);
  }

  public static void Sisymm(long n, double[] S, double[] Si) {
    OptimiserControllerJNI.Sisymm(n, S, Si);
  }

  public static short OptSemi(long n, long m, double[] w_opt, double[] g, double[] Q, double[][] AAA, double[] B) {
    return OptimiserControllerJNI.OptSemi(n, m, w_opt, g, Q, AAA, B);
  }

  public static short OptSemiGen(long N, long M, double[] X, double[] C, double[] AA, double[] BB, long top) {
    return OptimiserControllerJNI.OptSemiGen(N, M, X, C, AA, BB, top);
  }

  public static void vecvec2symmat(long n, double[] b, double[] a, double[] AA) {
    OptimiserControllerJNI.vecvec2symmat(n, b, a, AA);
  }

  public static void Amake(long n, double[] base, double[] a, double b, double[] AA, double B) {
    OptimiserControllerJNI.Amake(n, base, a, b, AA, B);
  }

  public static short OptFundClass(long nf, long nc, double[] target, double value, double outvalue, double[] wW, double factor, int log) {
    return OptimiserControllerJNI.OptFundClass(nf, nc, target, value, outvalue, wW, factor, log);
  }

  public static void Factor2Cov(long n, long nfac, double[] FFC, double[][] FLOAD, double[] SSV, double[] QFIX) {
    OptimiserControllerJNI.Factor2Cov(n, nfac, FFC, FLOAD, SSV, QFIX);
  }

  public static void Factor2Var(long n, long nfac, double[] FFC, double[][] FLOAD, double[] SSV, double[] Variance) {
    OptimiserControllerJNI.Factor2Var(n, nfac, FFC, FLOAD, SSV, Variance);
  }

  public static int opt_fix(long n, double[] QFIX, double[] mask, int print, double tol) {
    return OptimiserControllerJNI.opt_fix(n, QFIX, mask, print, tol);
  }

  public static int eig_fix(long n, double[] QFIX) {
    return OptimiserControllerJNI.eig_fix(n, QFIX);
  }

  public static int quad_fix(long n, double[] QFIX, double[] mask) {
    return OptimiserControllerJNI.quad_fix(n, QFIX, mask);
  }

  public static void basic_factor_global_local_attribution(long n, long nl, long ng, double[][] FLOAD, double[] w, double[] Y, double[] G, double[] S, double[][] YS, double[] FFC, double[] SSV, double[] XMCTR, double[] FFMCTR, double[] SMCTR, double[] IsFVar, double[] IsXVar, double[] IsFVarpg, double[] GFX, double[] FMCTRpg, double[] IsXVarga, double[] FFX, double[] facrisk, int print, double[] FCgl) {
    OptimiserControllerJNI.basic_factor_global_local_attribution(n, nl, ng, FLOAD, w, Y, G, S, YS, FFC, SSV, XMCTR, FFMCTR, SMCTR, IsFVar, IsXVar, IsFVarpg, GFX, FMCTRpg, IsXVarga, FFX, facrisk, print, FCgl);
  }

  public static void basic_factor_global_local_attribution1(long n, long nl, long ng, double[][] FLOAD, double[] w, double[] Y, double[] G, double[] S, double[][] YS, double[] XMCTR, double[] FFMCTR, double[] IsFVar, double[] IsXVar, double[] IsFVarpg, double[] GFX, double[] FMCTRpg, double[] IsXVarga, double[] FFX, double[] facrisk, int print) {
    OptimiserControllerJNI.basic_factor_global_local_attribution1(n, nl, ng, FLOAD, w, Y, G, S, YS, XMCTR, FFMCTR, IsFVar, IsXVar, IsFVarpg, GFX, FMCTRpg, IsXVarga, FFX, facrisk, print);
  }

  public static double xCx(long n, double[] Q, double[] w) {
    return OptimiserControllerJNI.xCx(n, Q, w);
  }

  public static double gausspdf(double mean, double st, long reseed) {
    return OptimiserControllerJNI.gausspdf(mean, st, reseed);
  }

  public static void resampfront(long n, int nfac, String[] names, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double[] Iinitial, double delta, int revise, double[] FFC, double[][] FLOAD, double[] SSV, long ncomp, double[] Comp, int logg, String logfile, double gamma, long nsamp, double[] randrisk, double[] randreturn, long npoints, double[] risks, double[] rreturns, double[] mask) {
    OptimiserControllerJNI.resampfront(n, nfac, names, m, AAA, L, U, alpha, benchmark, Q, Iinitial, delta, revise, FFC, FLOAD, SSV, ncomp, Comp, logg, logfile, gamma, nsamp, randrisk, randreturn, npoints, risks, rreturns, mask);
  }

  public static void manyVars(long n, double[] Q, double[] x, double[] AssetVars, long nmask, long[] masks, double[] MaskVars) {
    OptimiserControllerJNI.manyVars(n, Q, x, AssetVars, nmask, masks, MaskVars);
  }

  public static void ManyVarsD(long n, double[] SV, double[] x, double[] AssetVars, long nmask, long[] masks, double[] MaskVars) {
    OptimiserControllerJNI.ManyVarsD(n, SV, x, AssetVars, nmask, masks, MaskVars);
  }

  public static void manyVarsX(long n, long nf, double[] Q, double[] x, double[] AssetVars, long nmask, long[] masks, double[] MaskVars) {
    OptimiserControllerJNI.manyVarsX(n, nf, Q, x, AssetVars, nmask, masks, MaskVars);
  }

  public static void dmxtmulv(long n, long m, double[] G, double[] F, double[] GFX) {
    OptimiserControllerJNI.dmxtmulv(n, m, G, F, GFX);
  }

  public static void dmxmulv(long n, long m, double[] G, double[] F, double[] GFX) {
    OptimiserControllerJNI.dmxmulv(n, m, G, F, GFX);
  }

  public static void dmxtmultv(long n, long m, double[] G, double[] F, double[] GFX) {
    OptimiserControllerJNI.dmxtmultv(n, m, G, F, GFX);
  }

  public static void BITA_dgemv(String trans, long m, long n, double alpha, double[] a, long lda, double[] x, long incx, double beta, double[] y, long incy) {
    OptimiserControllerJNI.BITA_dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
  }

  public static void SriskAttribution(long n, double[] SSV, double[] x, long nsect, long[] sectdef, double[] Rctr, double[] TRctr) {
    OptimiserControllerJNI.SriskAttribution(n, SSV, x, nsect, sectdef, Rctr, TRctr);
  }

  public static void SvarianceAttribution(long n, double[] SSV, double[] x, long nsect, long[] sectdef, double[] Rctr, double[] TRctr) {
    OptimiserControllerJNI.SvarianceAttribution(n, SSV, x, nsect, sectdef, Rctr, TRctr);
  }

  public static void FriskAttribution(long n, long nl, double[] FFC, double[][] FLOAD, double[] x, long nsect, long[] sectdef, long ng, double[] G, double[][] YS, long nfgroup, long[] fgroupdef, long nggroup, long[] ggroupdef, double[] TotalRisks, double[] GlobalRisks, double[] LocalRisks, double[] TotalBreak, double[] GlobalBreak, double[] LocalBreak) {
    OptimiserControllerJNI.FriskAttribution(n, nl, FFC, FLOAD, x, nsect, sectdef, ng, G, YS, nfgroup, fgroupdef, nggroup, ggroupdef, TotalRisks, GlobalRisks, LocalRisks, TotalBreak, GlobalBreak, LocalBreak);
  }

  public static long FvarianceAttribution(long n, long nl, double[] FFC, double[][] FLOAD, double[] x, long nsect, long[] sectdef, long ng, double[] G, double[][] YS, long nfgroup, long[] fgroupdef, long nggroup, long[] ggroupdef, double[] TotalRisks, double[] GlobalRisks, double[] LocalRisks, double[] TotalBreak, double[] GlobalBreak, double[] LocalBreak, int stdev, double[] Mineg) {
    return OptimiserControllerJNI.FvarianceAttribution(n, nl, FFC, FLOAD, x, nsect, sectdef, ng, G, YS, nfgroup, fgroupdef, nggroup, ggroupdef, TotalRisks, GlobalRisks, LocalRisks, TotalBreak, GlobalBreak, LocalBreak, stdev, Mineg);
  }

  public static void FexposureAttribution(long n, long nl, double[][] FLOAD, double[] x, long nsect, long[] sectdef, long nfgroup, long[] fgroupdef, double[] TotalExp, double[] TotalBreak) {
    OptimiserControllerJNI.FexposureAttribution(n, nl, FLOAD, x, nsect, sectdef, nfgroup, fgroupdef, TotalExp, TotalBreak);
  }

  public static void MCTR_Beta(String[] Modelnames, long mn, String[] names, long n, long nf, double[] FFC, double[][] FLOAD, double[] SSV, double[] w, double[] benchmark, double[] MMCTR, double[] Bbeta) {
    OptimiserControllerJNI.MCTR_Beta(Modelnames, mn, names, n, nf, FFC, FLOAD, SSV, w, benchmark, MMCTR, Bbeta);
  }

  public static int SOCPopt1(long n, long m, long[] md, double[] c, double[] A, double[] b, double[] w, double delt, double nu) {
    return OptimiserControllerJNI.SOCPopt1(n, m, md, c, A, b, w, delt, nu);
  }

  public static int SOCPopt(long n, long m, long[] md, double[] c, double[] A, double[] b, double[] w_opt, double delt, double nu, long maxiter, double RR, double gapconv, int log) {
    return OptimiserControllerJNI.SOCPopt(n, m, md, c, A, b, w_opt, delt, nu, maxiter, RR, gapconv, log);
  }

  public static int SOCPgenopt(long n, long m, long[] md, double[] c, double[] A, double[] b, double[] w, long nb, double[] z, double delt, double nu, long maxiter, double gapconv, int log) {
    return OptimiserControllerJNI.SOCPgenopt(n, m, md, c, A, b, w, nb, z, delt, nu, maxiter, gapconv, log);
  }

  public static void testSOCPinf() {
    OptimiserControllerJNI.testSOCPinf();
  }

  public static void SOCPinfeasHomogtDUMP(long n, long m, int[] ncone, double[] c, double[] A, double[] b, double[] x, double[] y, double[] s, double[] tau, double[] kappa, long maxit, double beta, double delta, double ccomp, double cgap, int signtest, double changeratio, double rhoconv, int log, String outfile, String SOCPdump) {
    OptimiserControllerJNI.SOCPinfeasHomogtDUMP(n, m, ncone, c, A, b, x, y, s, tau, kappa, maxit, beta, delta, ccomp, cgap, signtest, changeratio, rhoconv, log, outfile, SOCPdump);
  }

  public static short SOCPinfeasHomogt(long n, long m, int[] ncone, double[] c, double[] A, double[] b, double[] x, double[] y, double[] s, double[] tau, double[] kappa, long maxit, double beta, double delta, double ccomp, double cgap, int signtest, double changeratio, double rhoconv, int log, String outfile, String SOCPdump) {
    return OptimiserControllerJNI.SOCPinfeasHomogt(n, m, ncone, c, A, b, x, y, s, tau, kappa, maxit, beta, delta, ccomp, cgap, signtest, changeratio, rhoconv, log, outfile, SOCPdump);
  }

  public static void RootProcessQ(long n, double[] Q, double[] RQ, double[] RQm1) {
    OptimiserControllerJNI.RootProcessQ(n, Q, RQ, RQm1);
  }

  public static void RootQ(long n, double[] Q, double[] RQ, double[] RQm1) {
    OptimiserControllerJNI.RootQ(n, Q, RQ, RQm1);
  }

  public static void RootQgram(long n, double[] Q, double[] RQ, double[] RQm1) {
    OptimiserControllerJNI.RootQgram(n, Q, RQ, RQm1);
  }

  public static void RootQold(long n, double[] Q, double[] RQ, double[] RQm1) {
    OptimiserControllerJNI.RootQold(n, Q, RQ, RQm1);
  }

  public static int fixA(long n, double[] A, int[] p, int overite) {
    return OptimiserControllerJNI.fixA(n, A, p, overite);
  }

  public static void DroppingOut(long N, long n, double[] Q, double[] initial, double[] modVar, double[] centre_shift) {
    OptimiserControllerJNI.DroppingOut(N, n, Q, initial, modVar, centre_shift);
  }

  public static short SOCPlstest(long n, long m, double[] w_opt, double[][] AAA, double[] Q, double[] alpha, int full, double rmin, double rmax, double[] L, double[] U, double val, double TopRisk, double[] dalpha, double MaxDalpha, long nabs, double[][] Abs_A, double[] Uabs, double[] bench, double[] initial) {
    return OptimiserControllerJNI.SOCPlstest(n, m, w_opt, AAA, Q, alpha, full, rmin, rmax, L, U, val, TopRisk, dalpha, MaxDalpha, nabs, Abs_A, Uabs, bench, initial);
  }

  public static short SOCPRobust(long n, long m, double[] w_opt, double[][] AAA, double[] L, double[] U, int nf, double[] SSV, double[][] FLOAD, double[] FFC, double[] alpha, double[] meanFE, double[] covFE, double maxmeanFE, double maxstderrorFE, double gamma, double maxRisk, double[] bench, double[] initial, int mFE, int rFE, double[] sectors) {
    return OptimiserControllerJNI.SOCPRobust(n, m, w_opt, AAA, L, U, nf, SSV, FLOAD, FFC, alpha, meanFE, covFE, maxmeanFE, maxstderrorFE, gamma, maxRisk, bench, initial, mFE, rFE, sectors);
  }

  public static short SOCPlsRobust(long n, long m, double[] w_opt, double[][] AAA, int nf, double[] SSV, double[][] FLOAD, double[] FFC, double[] alpha, int full, double rmin, double rmax, double[] L, double[] U, double val, double TopRisk, double[] dalpha, double MaxDalpha, double[] covalpha, double MaxValpha, long nabs, double[][] Abs_A, double[] Uabs, double[] bench, double[] initialm, double[] initials, int signtest, int fast) {
    return OptimiserControllerJNI.SOCPlsRobust(n, m, w_opt, AAA, nf, SSV, FLOAD, FFC, alpha, full, rmin, rmax, L, U, val, TopRisk, dalpha, MaxDalpha, covalpha, MaxValpha, nabs, Abs_A, Uabs, bench, initialm, initials, signtest, fast);
  }

  public static short SOCPlsRobustl(long n, long m, double[] w_opt, double[][] AAA, int nf, double[] SSV, double[][] FLOAD, double[] FFC, double[] alpha, int full, double rmin, double rmax, double[] L, double[] U, double val, double TopRisk, double[] dalpha, double MaxDalpha, double[] covalpha, double MaxValpha, long nabs, double[][] Abs_A, double[] Labs, double[] Uabs, double[] bench, double[] initialm, double[] initials, int signtest, int fast, int maxrobust, String SOCPdump) {
    return OptimiserControllerJNI.SOCPlsRobustl(n, m, w_opt, AAA, nf, SSV, FLOAD, FFC, alpha, full, rmin, rmax, L, U, val, TopRisk, dalpha, MaxDalpha, covalpha, MaxValpha, nabs, Abs_A, Labs, Uabs, bench, initialm, initials, signtest, fast, maxrobust, SOCPdump);
  }

  public static short SOCPlsRobustlC(long n, long m, double[] w_opt, double[][] AAA, int nf, double[] SSV, double[][] FLOAD, double[] FFC, double[] alpha, int full, double rmin, double rmax, double[] L, double[] U, double val, double TopRisk, double[] dalpha, double MaxDalpha, long nabs, double[][] Abs_A, double[] Labs, double[] Uabs, double[] bench, double[] initial, int signtest, int fast, int maxrobust, String SOCPdump, long ncomp, double[] Composites, double mintrade) {
    return OptimiserControllerJNI.SOCPlsRobustlC(n, m, w_opt, AAA, nf, SSV, FLOAD, FFC, alpha, full, rmin, rmax, L, U, val, TopRisk, dalpha, MaxDalpha, nabs, Abs_A, Labs, Uabs, bench, initial, signtest, fast, maxrobust, SOCPdump, ncomp, Composites, mintrade);
  }

  public static void Projection(long n, long m, double[] A, double[] x, double[] s, double[] M) {
    OptimiserControllerJNI.Projection(n, m, A, x, s, M);
  }

  public static void CovarianceInverter(long n, double[] C, double[] QFIX, double[] y, double[] Qm1d) {
    OptimiserControllerJNI.CovarianceInverter(n, C, QFIX, y, Qm1d);
  }

  public static void RankingConstraints(long n, double[] Q, double[] rank, double[] A, int nf, double[] FL, double[] SV) {
    OptimiserControllerJNI.RankingConstraints(n, Q, rank, A, nf, FL, SV);
  }

  public static short SOCPRanked(long n, long m, double[] w_opt, double[] A, double[] L, double[] U, int nf, double[] SV, double[] FL, double[] FC, double[] alpha, double maxRisk, double[] bench, int justalpha) {
    return OptimiserControllerJNI.SOCPRanked(n, m, w_opt, A, L, U, nf, SV, FL, FC, alpha, maxRisk, bench, justalpha);
  }

  public static int dsptrf(String uplo, long n, double[] ap, int[] ipiv) {
    return OptimiserControllerJNI.dsptrf(uplo, n, ap, ipiv);
  }

  public static int dsptrs(String uplo, long n, long nrhs, double[] ap, int[] ipiv, double[] b, long ldb) {
    return OptimiserControllerJNI.dsptrs(uplo, n, nrhs, ap, ipiv, b, ldb);
  }

  public static int applyA(String uplo, long n, long nrhs, double[] ap, int[] ipiv, double[] b, long ldb) {
    return OptimiserControllerJNI.applyA(uplo, n, nrhs, ap, ipiv, b, ldb);
  }

  public static int applyrootA(long n, long nrhs, double[] ap, int[] ipiv, double[] b, long ldb) {
    return OptimiserControllerJNI.applyrootA(n, nrhs, ap, ipiv, b, ldb);
  }

  public static int applyinverserootA(long n, long nrhs, double[] ap, int[] ipiv, double[] b, long ldb) {
    return OptimiserControllerJNI.applyinverserootA(n, nrhs, ap, ipiv, b, ldb);
  }

  public static void ReorderNames(long n, long[] order, String[] stocklist) {
    OptimiserControllerJNI.ReorderNames(n, order, stocklist);
  }

  public static short LPinterior(long n, long m, double[] x, double[] y, double[] s, double[] c, double[][] AAA, double[] b, int[] sign, int homo, double[] L, double eps, long nn, long mm, long ncnc, long nce, long nsns, long[] cmap, long[] ccmap, long[] wmap, long[] wwmap, Object Qxmul, double[] Q, double[] A) {
    return OptimiserControllerJNI.LPinterior(n, m, x, y, s, c, AAA, b, sign, homo, L, eps, nn, mm, ncnc, nce, nsns, cmap, ccmap, wmap, wwmap, Qxmul, Q, A);
  }

  public static short QPopt(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] L, double[] U, double[] Q, Object Qwmul, double eps, double toobig, short homog) {
    return OptimiserControllerJNI.QPopt(n, m, w_opt, c, AAA, L, U, Q, Qwmul, eps, toobig, homog);
  }

  public static short LPopt(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] L, double[] U, double eps, double toobig, short homog) {
    return OptimiserControllerJNI.LPopt(n, m, w_opt, c, AAA, L, U, eps, toobig, homog);
  }

  public static short QPbySeqLP(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] L, double[] U, double[] Q, Object Qwmul, double lpeps, double toobig, double qpeps, short homog) {
    return OptimiserControllerJNI.QPbySeqLP(n, m, w_opt, c, AAA, L, U, Q, Qwmul, lpeps, toobig, qpeps, homog);
  }

  public static short QPinterior(long n, long m, double[] x, double[] y, double[] s, double[] c, double[][] AAA, double[] b, int[] sign, int homo, double[] L, double eps, long nn, long mm, long ncnc, long nce, long nsns, long[] cmap, long[] ccmap, long[] wmap, long[] wwmap, Object Qxmul, double[] Q, double[] A) {
    return OptimiserControllerJNI.QPinterior(n, m, x, y, s, c, AAA, b, sign, homo, L, eps, nn, mm, ncnc, nce, nsns, cmap, ccmap, wmap, wwmap, Qxmul, Q, A);
  }

  public static void facmul(long n, long nf, double[] H, double[] x, double[] w_opt) {
    OptimiserControllerJNI.facmul(n, nf, H, x, w_opt);
  }

  public static void facmuli(long n, long nf, double[] H, double[] x, double[] w_opt) {
    OptimiserControllerJNI.facmuli(n, nf, H, x, w_opt);
  }

  public static void FastInverseFactorModelProcess(long n, long nf, double[][] FLOAD, double[] FFC, double[] SSV, double[] QMATRIX) {
    OptimiserControllerJNI.FastInverseFactorModelProcess(n, nf, FLOAD, FFC, SSV, QMATRIX);
  }

  public static void MakeUU(long n, double[] M, double[] UU) {
    OptimiserControllerJNI.MakeUU(n, M, UU);
  }

  public static void fastInverse(long n, double[] M, double[] DIAG, double[] x, double[] y) {
    OptimiserControllerJNI.fastInverse(n, M, DIAG, x, y);
  }

  public static short OmegaOpt(long n, long tlen, double[] DATA, String[] stocknames, double[] w_opt, double C, double R, double Low, double[] Gain, double[] Loss, int log) {
    return OptimiserControllerJNI.OmegaOpt(n, tlen, DATA, stocknames, w_opt, C, R, Low, Gain, Loss, log);
  }

  public static double FindR(long n, long tlen, double[] DATA, String[] stocknames, double Low) {
    return OptimiserControllerJNI.FindR(n, tlen, DATA, stocknames, Low);
  }

  public static short RobustOpt(long n, long m, double[] w_opt, double[] alpha, double[] A, double[] L, double[] U, int full, double rmin, double rmax, double val, long nabs, double[] Aabs, double[] Labs, double[] Uabs, int signtest, long nquad, int[] qtype, double[] cov, double[] Uq, double[] centres, long ncomp, double[] Composites, int fillin) {
    return OptimiserControllerJNI.RobustOpt(n, m, w_opt, alpha, A, L, U, full, rmin, rmax, val, nabs, Aabs, Labs, Uabs, signtest, nquad, qtype, cov, Uq, centres, ncomp, Composites, fillin);
  }

  public static short RobustOptU(long n, long m, double[] w_opt, double[] alpha, double[] A, double[] L, double[] U, int full, double rmin, double rmax, double val, long nabs, double[] Aabs, double[] Labs, double[] Uabs, int signtest, long nquad, int[] qtype, double[] cov, double[] Uq, double[] centres, long ncomp, double[] Composites, int fillin, double[] Ualpha) {
    return OptimiserControllerJNI.RobustOptU(n, m, w_opt, alpha, A, L, U, full, rmin, rmax, val, nabs, Aabs, Labs, Uabs, signtest, nquad, qtype, cov, Uq, centres, ncomp, Composites, fillin, Ualpha);
  }

  public static void QuadCVals(long n, double[] w, double[] alpha, double[] areturn, long nquad, int[] qtype, double[] cov, double[] Uq, double[] centres, double[] U, long ncomp, double[] Composites, int fillin) {
    OptimiserControllerJNI.QuadCVals(n, w, alpha, areturn, nquad, qtype, cov, Uq, centres, U, ncomp, Composites, fillin);
  }

  public static void IncreaseL(long n, long m, long ncomp, double[] L, double[] Composites) {
    OptimiserControllerJNI.IncreaseL(n, m, ncomp, L, Composites);
  }

  public static short OmegaSVOpt(long n, long tlen, double[] DATA, String[] stocknames, double[] w_opt, double C, double R, double Low, double[] Gain, double[] SVar, int log) {
    return OptimiserControllerJNI.OmegaSVOpt(n, tlen, DATA, stocknames, w_opt, C, R, Low, Gain, SVar, log);
  }

  public static short OmegaGeneral(long n, long tlen, long m, double[][] Omega_DATA, String[] stocknames, double[] w_opt, double C, double R, double[] L, double[] U, double[][] AAA, double[] Top, double[] Bot, double[] Prob, int log, int useSV, String outfile, double gpower, double lpower) {
    return OptimiserControllerJNI.OmegaGeneral(n, tlen, m, Omega_DATA, stocknames, w_opt, C, R, L, U, AAA, Top, Bot, Prob, log, useSV, outfile, gpower, lpower);
  }

  public static short OmegaGeneralP(long n, long tlen, long m, double[][] Omega_DATA, String[] stocknames, double[] w_opt, double C, double p, double[] L, double[] U, double[][] AAA, double[] Top, double[] Bot, double[] Prob, double[] Rbase, int log, int useSV, String outfile) {
    return OptimiserControllerJNI.OmegaGeneralP(n, tlen, m, Omega_DATA, stocknames, w_opt, C, p, L, U, AAA, Top, Bot, Prob, Rbase, log, useSV, outfile);
  }

  public static void OmegaGeneralPDump(long n, long tlen, long m, double[][] Omega_DATA, String[] stocknames, double[] w_opt, double C, double p, double[] L, double[] U, double[][] AAA, double[] Top, double[] Bot, double[] Prob, double[] Rbase, int log, int useSV, String outfile) {
    OptimiserControllerJNI.OmegaGeneralPDump(n, tlen, m, Omega_DATA, stocknames, w_opt, C, p, L, U, AAA, Top, Bot, Prob, Rbase, log, useSV, outfile);
  }

  public static void OmegaProps(long n, long tlen, double[][] Omega_DATA, double[] w, double R, double[] Prob, double[] Top, double[] Bot, double[] gains, double[] losses, double[] isolated_gains, double[] isolated_losses) {
    OptimiserControllerJNI.OmegaProps(n, tlen, Omega_DATA, w, R, Prob, Top, Bot, gains, losses, isolated_gains, isolated_losses);
  }

  public static short QPbySOCP(long n, long m, double[] w_opt, double[] A, double[] L, double[] U, double[] alpha, double[] Q, double[] S, double tRad) {
    return OptimiserControllerJNI.QPbySOCP(n, m, w_opt, A, L, U, alpha, Q, S, tRad);
  }

  public static void OmegaH(long n, long tlen, double[] DATA, double[] w, double R, double[] Omega, double[] Grad, double[] H) {
    OptimiserControllerJNI.OmegaH(n, tlen, DATA, w, R, Omega, Grad, H);
  }

  public static void clean_w(long n, double[] w) {
    OptimiserControllerJNI.clean_w(n, w);
  }

  public static double trace(long n, double[] Q) {
    return OptimiserControllerJNI.trace(n, Q);
  }

  public static short anneal(long n, double[] w_opt, double[] L, double[] U, double[] step, Object calcfx, double t, double rt, int ns) {
    return OptimiserControllerJNI.anneal(n, w_opt, L, U, step, calcfx, t, rt, ns);
  }

  public static void ThetaMulti(long n, int nfac, long m, String[] stocknames, long T, double[] alpha, double[] benchmark, double[] Initial, double[] gamma, double[] delta, double[] L, double[] U, double[] A, double[] FC, double[] FL, double[] SV, double[] d, double[] Th) {
    OptimiserControllerJNI.ThetaMulti(n, nfac, m, stocknames, T, alpha, benchmark, Initial, gamma, delta, L, U, A, FC, FL, SV, d, Th);
  }

  public static void Lsmooth(long n, long m, double[] w_opt, double[] a, double[] A, double[] b, double gamma, double eps, int[] sign, double[] L, double[] Q, long nfac, double[] FL, double[] FC, double[] SV) {
    OptimiserControllerJNI.Lsmooth(n, m, w_opt, a, A, b, gamma, eps, sign, L, Q, nfac, FL, FC, SV);
  }

  public static void SemiVar(long n, long tlen, double[][] Omega_DATA, double[] w, double R, double[] Prob, double[] Top, double[] areturn, double[] Bot) {
    OptimiserControllerJNI.SemiVar(n, tlen, Omega_DATA, w, R, Prob, Top, areturn, Bot);
  }

  public static short GeneralLongOpt(long n, long m, String[] stocknames, double[] w_opt, double[][] AAA, double[] L, double[] U, Object f_val, Object g_val, Object h_val, int log) {
    return OptimiserControllerJNI.GeneralLongOpt(n, m, stocknames, w_opt, AAA, L, U, f_val, g_val, h_val, log);
  }

  public static short LPhelper(long n, long m, double[] w_opt, double[][] AAA, double[] c, double[] L, double[] U, int log, String logfile) {
    return OptimiserControllerJNI.LPhelper(n, m, w_opt, AAA, c, L, U, log, logfile);
  }

  public static short LPgeneral(long n, long m, double[] w_opt, double[][] AAA, double[] c, double[] L, double[] U, long nabs, double[] Aabs, double[] Labs, double[] Uabs, double[] initial, double[] buy, double[] sell, double delta, double LVU, double LVL, double rmin, double rmax, int log, String logfile, double rmin_base, double rmax_base) {
    return OptimiserControllerJNI.LPgeneral(n, m, w_opt, AAA, c, L, U, nabs, Aabs, Labs, Uabs, initial, buy, sell, delta, LVU, LVL, rmin, rmax, log, logfile, rmin_base, rmax_base);
  }

  public static void RobustOptDump(long n, long m, double[] w, double[] alpha, double[] A, double[] L, double[] U, int full, double rmin, double rmax, double val, long nabs, double[] Aabs, double[] Labs, double[] Uabs, int signtest, long nquad, int[] qtype, double[] cov, double[] Uq, double[] centres, long ncomp, double[] Comps, int fillin, String outfile) {
    OptimiserControllerJNI.RobustOptDump(n, m, w, alpha, A, L, U, full, rmin, rmax, val, nabs, Aabs, Labs, Uabs, signtest, nquad, qtype, cov, Uq, centres, ncomp, Comps, fillin, outfile);
  }

  public static short LPFullNewton(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] b, double xci, double tau, double eps) {
    return OptimiserControllerJNI.LPFullNewton(n, m, w_opt, c, AAA, b, xci, tau, eps);
  }

  public static short LPbySOCPp(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] b) {
    return OptimiserControllerJNI.LPbySOCPp(n, m, w_opt, c, AAA, b);
  }

  public static short LPbySOCP(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] L, double[] U) {
    return OptimiserControllerJNI.LPbySOCP(n, m, w_opt, c, AAA, L, U);
  }

  public static short LPstraight(long n, long m, double[] w_opt, double[] c, double[][] AAA, double[] L, double[] U) {
    return OptimiserControllerJNI.LPstraight(n, m, w_opt, c, AAA, L, U);
  }

  public static short GainLossOpt(long n, long tlen, double[] DATA, double[] R, double C, double llambda, double[] w_opt, long m, double[] L, double[] U, double[][] AAA, double gpower, double lpower, String[] stocknames, double[] alpha, int nf, double[] SV, double[] FC, double[] FL) {
    return OptimiserControllerJNI.GainLossOpt(n, tlen, DATA, R, C, llambda, w_opt, m, L, U, AAA, gpower, lpower, stocknames, alpha, nf, SV, FC, FL);
  }

  public static short GainLossOptGen(long n, long tlen, double[] DATA, double[] R, double C, double llambda, double[] w_opt, long m, double[] L, double[] U, double[][] AAA, double gpower, double lpower, String[] stocknames, double[] alpha, int nf, double[] SV, double[] FC, double[] FL) {
    return OptimiserControllerJNI.GainLossOptGen(n, tlen, DATA, R, C, llambda, w_opt, m, L, U, AAA, gpower, lpower, stocknames, alpha, nf, SV, FC, FL);
  }

  public static short GLOptimise(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double C, double lambda, double gpower, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.GLOptimise(n, nfac, stocknames, tlen, DATA, R, C, lambda, gpower, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L);
  }

  public static short GLOptimiseR(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double C, double lambda, double gpower, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double minRisk, double maxRisk, double[] gammaback, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.GLOptimiseR(n, nfac, stocknames, tlen, DATA, R, C, lambda, gpower, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, minRisk, maxRisk, gammaback, five, ten, forty, issues);
  }

  public static short GLOptimiseRC(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double C, double lambda, double gpower, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, int costs, double kappa, double[] buy, double[] sell, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double minRisk, double maxRisk, double[] gammaback, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.GLOptimiseRC(n, nfac, stocknames, tlen, DATA, R, C, lambda, gpower, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, costs, kappa, buy, sell, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, minRisk, maxRisk, gammaback, five, ten, forty, issues);
  }

  public static void GLProp(long n, String[] stocknames, long tlen, double[] DATA, double[] R, double gpower, double lpower, double[] prob, double[] Gain, double[] Loss, double[] w, double[] MargGain, double[] MargLoss) {
    OptimiserControllerJNI.GLProp(n, stocknames, tlen, DATA, R, gpower, lpower, prob, Gain, Loss, w, MargGain, MargLoss);
  }

  public static int bunchf(int n, double[] C, int[] piv) {
    return OptimiserControllerJNI.bunchf(n, C, piv);
  }

  public static short MVLOptimise(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double lambda, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.MVLOptimise(n, nfac, stocknames, tlen, DATA, R, lambda, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L);
  }

  public static short MVLOptimiseg(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double lambda, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double[] gammaback) {
    return OptimiserControllerJNI.MVLOptimiseg(n, nfac, stocknames, tlen, DATA, R, lambda, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, gammaback);
  }

  public static short MVLOptimiseR(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double lambda, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double minRisk, double maxRisk, double[] gammaback, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.MVLOptimiseR(n, nfac, stocknames, tlen, DATA, R, lambda, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, minRisk, maxRisk, gammaback, five, ten, forty, issues);
  }

  public static short MVLOptimiseRC(long n, int nfac, String[] stocknames, long tlen, double[] DATA, double[] R, double lambda, double lpower, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, int costs, double kappa, double[] buy, double[] sell, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FC, double[] FL, double[] SV, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double minRisk, double maxRisk, double[] gammaback, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.MVLOptimiseRC(n, nfac, stocknames, tlen, DATA, R, lambda, lpower, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, costs, kappa, buy, sell, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FC, FL, SV, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, minRisk, maxRisk, gammaback, five, ten, forty, issues);
  }

  public static void GLO_internal_model(long n, long tlen, double[] DATA, double[] QBACK, double[] alphaback) {
    OptimiserControllerJNI.GLO_internal_model(n, tlen, DATA, QBACK, alphaback);
  }

  public static short CvarOptimise(long n, long tlen, double[] DATA, long number_included, double CVar_averse, double getRisk, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int round, double[] min_lot, double[] size_lot, int[] shake, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] ogamma, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.CvarOptimise(n, tlen, DATA, number_included, CVar_averse, getRisk, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, round, min_lot, size_lot, shake, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, ogamma, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L);
  }

  public static short CvarOptimiseCR(long n, long tlen, double[] DATA, long number_included, double CVar_averse, double getRisk, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int round, double[] min_lot, double[] size_lot, int[] shake, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] ogamma, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, int costs, double[] buy, double[] sell, int CVar_constraint, double CVarMin, double CVarMax, short relCvar) {
    return OptimiserControllerJNI.CvarOptimiseCR(n, tlen, DATA, number_included, CVar_averse, getRisk, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, round, min_lot, size_lot, shake, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, ogamma, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, costs, buy, sell, CVar_constraint, CVarMin, CVarMax, relCvar);
  }

  public static short CvarOptimiseC(long n, long tlen, double[] DATA, long number_included, double CVar_averse, double getRisk, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] Q, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int round, double[] min_lot, double[] size_lot, int[] shake, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] ogamma, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, int costs, double[] buy, double[] sell, int CVar_constraint, double CVarMin, double CVarMax) {
    return OptimiserControllerJNI.CvarOptimiseC(n, tlen, DATA, number_included, CVar_averse, getRisk, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, Q, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, round, min_lot, size_lot, shake, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, ogamma, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, costs, buy, sell, CVar_constraint, CVarMin, CVarMax);
  }

  public static double SemiVariance(long n, long tlen, double[] DATA, double[] w, double[] benchmark) {
    return OptimiserControllerJNI.SemiVariance(n, tlen, DATA, w, benchmark);
  }

  public static void GradSemiVariance(long n, long tlen, double[] DATA, double[] w, double[] benchmark, double[] gback) {
    OptimiserControllerJNI.GradSemiVariance(n, tlen, DATA, w, benchmark, gback);
  }

  public static void HessSemiVariance(long n, long tlen, double[] DATA, double[] w, double[] benchmark, double[] QBACK) {
    OptimiserControllerJNI.HessSemiVariance(n, tlen, DATA, w, benchmark, QBACK);
  }

  public static short SemiVarOptimise(long n, String[] stocknames, long tlen, double[] DATA, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double minSV, double maxSV, double[] gammaback, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.SemiVarOptimise(n, stocknames, tlen, DATA, w_opt, m, AAA, L, U, alpha, benchmark, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, minSV, maxSV, gammaback, five, ten, forty, issues);
  }

  public static short SemiVarOptimiseT(long n, String[] stocknames, long tlen, double[] DATA, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] mask, int log, String logfile, int longbasket, int shortbasket, double LSValuel, double[] Abs_L, double minSV, double maxSV, double[] gammaback, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.SemiVarOptimiseT(n, stocknames, tlen, DATA, w_opt, m, AAA, L, U, alpha, benchmark, gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, mask, log, logfile, longbasket, shortbasket, LSValuel, Abs_L, minSV, maxSV, gammaback, five, ten, forty, issues);
  }

  public static double CVarValue(long n, long tlen, double[] DATA, long number_included, double[] w) {
    return OptimiserControllerJNI.CVarValue(n, tlen, DATA, number_included, w);
  }

  public static void CVarGrad(long n, long tlen, double[] DATA, long number_included, double[] w, double[] grad) {
    OptimiserControllerJNI.CVarGrad(n, tlen, DATA, number_included, w, grad);
  }

  public static double CVarValueO(long n, long tlen, double[] DATA, long number_included, double[] w) {
    return OptimiserControllerJNI.CVarValueO(n, tlen, DATA, number_included, w);
  }

  public static double CVarValuen(long n, long tlen, double[] DATA, long number_included, double[] w) {
    return OptimiserControllerJNI.CVarValuen(n, tlen, DATA, number_included, w);
  }

  public static short OptCVar(long nstocks, long m, long t, double beta, double[] w_opt, double[] DATA, double[] lower, double[] upper, double[] A, int log, double[] CVaR, double[] VaR) {
    return OptimiserControllerJNI.OptCVar(nstocks, m, t, beta, w_opt, DATA, lower, upper, A, log, CVaR, VaR);
  }

  public static short OptGL(long nstocks, long m, long t, double[] R, double[] w_opt, double[] DATA, double[] lower, double[] upper, double[] A, double C, int log, double[] Gain, double[] Loss) {
    return OptimiserControllerJNI.OptGL(nstocks, m, t, R, w_opt, DATA, lower, upper, A, C, log, Gain, Loss);
  }

  public static int AQAmake(long n, long m, double[] A, double[] Q, double[] X, double[] S, double[] MAT) {
    return OptimiserControllerJNI.AQAmake(n, m, A, Q, X, S, MAT);
  }

  public static int FixedAtEnd(long n, double[] L, double[] U, long[] order) {
    return OptimiserControllerJNI.FixedAtEnd(n, L, U, order);
  }

  public static short SOCPportfolio(long n, long m, double[] w_opt, double[] L, double[] U, double[][] AAA, double[] alpha, double[] benchmark, double[] initial, double[] buy, double[] sell, int costs, double delta, double psum, double psumL, double nsum, double nsumU, double rmax, double rmin, long mabs, double[] A_abs, double[] L_abs, double[] U_abs, double[] FC, int nfac, double[] FL, double[] SV, double maxrisk, double maxarisk, int meanstd, double meanstdl, double[] lambda1, double[] lambda2, double[] lambda3, double[] optvalue, String inputData, int log, String logfile, double[] min_trade, double[] min_hold, int basket, int trades, double[] minlot, double[] sizelot, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.SOCPportfolio(n, m, w_opt, L, U, AAA, alpha, benchmark, initial, buy, sell, costs, delta, psum, psumL, nsum, nsumU, rmax, rmin, mabs, A_abs, L_abs, U_abs, FC, nfac, FL, SV, maxrisk, maxarisk, meanstd, meanstdl, lambda1, lambda2, lambda3, optvalue, inputData, log, logfile, min_trade, min_hold, basket, trades, minlot, sizelot, five, ten, forty, issues);
  }

  public static void getmacaddress(String nnn) {
    OptimiserControllerJNI.getmacaddress(nnn);
  }

  public static short Optimise_Entropy(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double kappa, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int longbasket, int shortbasket, int tradebuy, int tradesell, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.Optimise_Entropy(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, kappa, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, longbasket, shortbasket, tradebuy, tradesell, LSValuel, Abs_L);
  }

  public static void EntropyUtility(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] initial, double[] Q, double gamma, double kappa, double[] alpha, double[] tcost, double[] utility, double[] gradutility, long ncomp, double[] Composite) {
    OptimiserControllerJNI.EntropyUtility(n, nfac, stocknames, w, benchmark, initial, Q, gamma, kappa, alpha, tcost, utility, gradutility, ncomp, Composite);
  }

  public static short Optimise_EntropyU(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double MVlambda, double entropy_gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double MVUmin, double MVUmax, double[] ogamma, double[] mask, int lg, String logfile, int longbasket, int shortbasket, int tradebuy, int tradesell, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.Optimise_EntropyU(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, MVlambda, entropy_gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, MVUmin, MVUmax, ogamma, mask, lg, logfile, longbasket, shortbasket, tradebuy, tradesell, LSValuel, Abs_L);
  }

  public static short OptimiseCrossEntropy(long n, int nfac, String[] stocknames, double[] w_out, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double MVlambda, double entropy_gamma, double[] initial, double delta, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_Round, double[] min_lot, double[] size_lot, int[] shake, double[] FFC, double[][] FLOAD, double[] SSV, double MVUmin, double MVUmax, double[] ogamma, double[] mask, int lg, String logfile) {
    return OptimiserControllerJNI.OptimiseCrossEntropy(n, nfac, stocknames, w_out, m, AAA, L, U, alpha, benchmark, QMATRIX, MVlambda, entropy_gamma, initial, delta, basket, trades, revise, min_holding, min_trade, m_Round, min_lot, size_lot, shake, FFC, FLOAD, SSV, MVUmin, MVUmax, ogamma, mask, lg, logfile);
  }

  public static void SDPsvec(long n, double[] S, double[] v) {
    OptimiserControllerJNI.SDPsvec(n, S, v);
  }

  public static void SDPsMat(long n, double[] v, double[] S) {
    OptimiserControllerJNI.SDPsMat(n, v, S);
  }

  public static int nullA(long m, long n, double[] A, double[] Z) {
    return OptimiserControllerJNI.nullA(m, n, A, Z);
  }

  public static short LPQN(long n, long m, double[] w_opt, double[] A, double[] b, double[] c) {
    return OptimiserControllerJNI.LPQN(n, m, w_opt, A, b, c);
  }

  public static short GAUSS_NEWTON_Optimiser(long ncone, long[] cone, long[] typecone, long m, double[] x, double[] s, double[] y, double[] A, double[] b, double[] c) {
    return OptimiserControllerJNI.GAUSS_NEWTON_Optimiser(ncone, cone, typecone, m, x, s, y, A, b, c);
  }

  public static void packed2symm(int n, double[] a) {
    OptimiserControllerJNI.packed2symm(n, a);
  }

  public static void symm2packed(int n, double[] a) {
    OptimiserControllerJNI.symm2packed(n, a);
  }

  public static short Conic_General(long ncone, int[] cone, int[] typecone, long m, double[] x, double[] s, double[] y, double[] A, double[] b, double[] c, double[] tau, double[] kappa, double comptoll, double gaptoll, double stepmax, int straight, int fastbreak, int log, String outfile, int method) {
    return OptimiserControllerJNI.Conic_General(ncone, cone, typecone, m, x, s, y, A, b, c, tau, kappa, comptoll, gaptoll, stepmax, straight, fastbreak, log, outfile, method);
  }

  public static void get_w(long n, double[] s, double[] x, double[] w) {
    OptimiserControllerJNI.get_w(n, s, x, w);
  }

  public static void WtransSDP(long n, double[] A, double[] w, double[] WA, boolean inv, boolean squared) {
    OptimiserControllerJNI.WtransSDP(n, A, w, WA, inv, squared);
  }

  public static void applyXSDP(long n, double[] x, double[] a, double[] xa) {
    OptimiserControllerJNI.applyXSDP(n, x, a, xa);
  }

  public static void applyXm1SDP(long n, double[] x, double[] a, double[] xa) {
    OptimiserControllerJNI.applyXm1SDP(n, x, a, xa);
  }

  public static void SDPsymm2MCAR(long n, long nc, double[] Q, double[] A) {
    OptimiserControllerJNI.SDPsymm2MCAR(n, nc, Q, A);
  }

  public static void factor_model_process_inverse(long n, long nfac, double[] Q, double[] QMATRIX) {
    OptimiserControllerJNI.factor_model_process_inverse(n, nfac, Q, QMATRIX);
  }

  public static void facmul_and_inv(long n, long nfac, double[] Q, double[] x, double[] w_opt, int inv) {
    OptimiserControllerJNI.facmul_and_inv(n, nfac, Q, x, w_opt, inv);
  }

  public static double small_round(double eps) {
    return OptimiserControllerJNI.small_round(eps);
  }

  public static void make_indexM(int n, double[] a, int[] ia, int[] ja, int[] zerorank) {
    OptimiserControllerJNI.make_indexM(n, a, ia, ja, zerorank);
  }

  public static int pull_BITA(int[] n, double[] dn, int[] iju, int[] ju, int[] iu, double[] un, int[] il, int[] jl, double[] x, double[] tolpiv, int[] flag__, double[] sign, int[] pivot_nzp, int[] pivot_nju) {
    return OptimiserControllerJNI.pull_BITA(n, dn, iju, ju, iu, un, il, jl, x, tolpiv, flag__, sign, pivot_nzp, pivot_nju);
  }

  public static int sns_BITA(int[] n, int[] p, double[] d__, int[] iju, int[] ju, int[] iu, double[] u, double[] z__, double[] b, double[] tmp, int[] pivot_nzp, int[] pivot_nju) {
    return OptimiserControllerJNI.sns_BITA(n, p, d__, iju, ju, iu, u, z__, b, tmp, pivot_nzp, pivot_nju);
  }

  public static int ssf_BITA(int[] mua, int[] n, int[] p, int[] ip, int[] ia, int[] ja, int[] iju, int[] ju, int[] iu, int[] jumax, int[] q, int[] jl, int[] flag__, int[] lenju, int[] lenu) {
    return OptimiserControllerJNI.ssf_BITA(mua, n, p, ip, ia, ja, iju, ju, iu, jumax, q, jl, flag__, lenju, lenu);
  }

  public static void A2U(int n, int[] iu, int[] ju, int[] iju, double[] a, double[] U, int[] p) {
    OptimiserControllerJNI.A2U(n, iu, ju, iju, a, U, p);
  }

  public static void UseSparseCh(int n, double[] M, double[] b) {
    OptimiserControllerJNI.UseSparseCh(n, M, b);
  }

  public static short Conic_VeryGeneral(long ncone, int[] cone, int[] typecone, long m, double[] x, double[] s, double[] y, double[] A, double[] b, double[] c, double[] tau, double[] kappa, double comptoll, double gaptoll, double stepmax, int straight, int fastbreak, int log, String outfile, int method, int homog, int nf, double[] SV, double[] FL, double[] FC, long fcone) {
    return OptimiserControllerJNI.Conic_VeryGeneral(ncone, cone, typecone, m, x, s, y, A, b, c, tau, kappa, comptoll, gaptoll, stepmax, straight, fastbreak, log, outfile, method, homog, nf, SV, FL, FC, fcone);
  }

  public static void lowrank_facmul_and_inv(long n, long nfac, double[] LL, double[] A, double[] x, double[] y, int inv, int[] Apiv) {
    OptimiserControllerJNI.lowrank_facmul_and_inv(n, nfac, LL, A, x, y, inv, Apiv);
  }

  public static void process_lowrank_plus_symm_inverse(long n, long nfac, double[] LL, double[] A, double[] LLm1, int[] Apiv) {
    OptimiserControllerJNI.process_lowrank_plus_symm_inverse(n, nfac, LL, A, LLm1, Apiv);
  }

  public static void W2trans(long ncone, double[] A, double[] w, double[] W2A) {
    OptimiserControllerJNI.W2trans(ncone, A, w, W2A);
  }

  public static void Wtrans(long ncone, double[] A, double[] w, double[] WA) {
    OptimiserControllerJNI.Wtrans(ncone, A, w, WA);
  }

  public static void SDPwsymm2MCAR(long n, long nc, double wc, double[] Q, double[] A) {
    OptimiserControllerJNI.SDPwsymm2MCAR(n, nc, wc, Q, A);
  }

  public static void SDPvec2MCAR(long n, long nc, double[] Qnci, double[] A) {
    OptimiserControllerJNI.SDPvec2MCAR(n, nc, Qnci, A);
  }

  public static short RiskParityOpt(long n, long nsect, int nf, double[] w_opt, double[] alpha, double[] sectors, double[] SV, double[] FC, double[] FL, double[] conc, double[] lambda, int longonly, int[] rank, int do_parity, int fastbreak, int link_extra, int alpha_extra, double[] sos_check, double budget) {
    return OptimiserControllerJNI.RiskParityOpt(n, nsect, nf, w_opt, alpha, sectors, SV, FC, FL, conc, lambda, longonly, rank, do_parity, fastbreak, link_extra, alpha_extra, sos_check, budget);
  }

  public static short RiskParitySolveF(long n, long nsect, int nf, double[] w_opt, double[] alpha, double[] sectors, double[] SV, double[] FC, double[] FL, double[] first, long nasme, double[] conc, int BFGS, int DiffGrad) {
    return OptimiserControllerJNI.RiskParitySolveF(n, nsect, nf, w_opt, alpha, sectors, SV, FC, FL, first, nasme, conc, BFGS, DiffGrad);
  }

  public static short RiskParitySolve(long n, long nsect, int nf, double[] w_opt, double[] alpha, double[] sectors, double[] SV, double[] FC, double[] FL, double[] conc, int BFGS, int DiffGrad) {
    return OptimiserControllerJNI.RiskParitySolve(n, nsect, nf, w_opt, alpha, sectors, SV, FC, FL, conc, BFGS, DiffGrad);
  }

  public static short RiskParitySolve2(long n, long nsect, int nf, double[] w_opt, double[] alpha, double[] sectors, double[] SV, double[] FC, double[] FL, double[] conc, int BFGS, int DiffGrad, int seq, double lower, double gamma) {
    return OptimiserControllerJNI.RiskParitySolve2(n, nsect, nf, w_opt, alpha, sectors, SV, FC, FL, conc, BFGS, DiffGrad, seq, lower, gamma);
  }

  public static short SharpOpt(long n, long m, int nfac, double[] w_opt, double[] benchmark, double[] alpha, double[] L, double[] U, double[] A, double[] FC, double[] SV, double[] FL, int no_opt, int BFGS, int DiffGrad, int log) {
    return OptimiserControllerJNI.SharpOpt(n, m, nfac, w_opt, benchmark, alpha, L, U, A, FC, SV, FL, no_opt, BFGS, DiffGrad, log);
  }

  public static short OptimiseGeneral(long n, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] c, double[] H, Object Gen_U, Object Gen_Grad, Object Gen_Hess) {
    return OptimiserControllerJNI.OptimiseGeneral(n, w_opt, m, AAA, L, U, c, H, Gen_U, Gen_Grad, Gen_Hess);
  }

  public static int CanCastAsInteger(double[] d, double xmin, double xmax) {
    return OptimiserControllerJNI.CanCastAsInteger(d, xmin, xmax);
  }

  public static int dgetrf_BITA(int[] m, int[] n, double[] a, int[] lda, int[] ipiv, int[] info) {
    return OptimiserControllerJNI.dgetrf_BITA(m, n, a, lda, ipiv, info);
  }

  public static int dgetri_BITA(int[] n, double[] a, int[] lda, int[] ipiv, double[] work, int[] lwork, int[] info) {
    return OptimiserControllerJNI.dgetri_BITA(n, a, lda, ipiv, work, lwork, info);
  }

  public static int dgetrs_BITA(String trans, int[] n, int[] nrhs, double[] a, int[] lda, int[] ipiv, double[] b, int[] ldb, int[] info) {
    return OptimiserControllerJNI.dgetrs_BITA(trans, n, nrhs, a, lda, ipiv, b, ldb, info);
  }

  public static short Accumulation5_10_40(long basket, long trades, int way) {
    return OptimiserControllerJNI.Accumulation5_10_40(basket, trades, way);
  }

  public static double EndRound(double a) {
    return OptimiserControllerJNI.EndRound(a);
  }

  public static short OptimiseGeneralBarrier(long n, double[] x, double[] y, double[] z, long m, double[] A, double[] b, Object Bar_U, Object Bar_Grad, Object Bar_Hess, double nu, double mudec, double beta, double e0, int[] iter) {
    return OptimiserControllerJNI.OptimiseGeneralBarrier(n, x, y, z, m, A, b, Bar_U, Bar_Grad, Bar_Hess, nu, mudec, beta, e0, iter);
  }

  public static short OptimiseNLC(long n, double[] x, double[] y, double[] z, long m, Object Bar_Ab, Object Bar_U, Object Bar_Grad, Object Bar_Hess, double tol, double nu, double mudec, double Mc, double mexp, double shape, int[] iter, int iprint, int conventional) {
    return OptimiserControllerJNI.OptimiseNLC(n, x, y, z, m, Bar_Ab, Bar_U, Bar_Grad, Bar_Hess, tol, nu, mudec, Mc, mexp, shape, iter, iprint, conventional);
  }

  public static short OptimiseNLC1(long n, double[] x, double[] y, double[] z, long m, Object Bar_Ab, Object Bar_U, Object Bar_Grad, Object Bar_Hess, double tol, int[] iter, int iprint, double rho, double theta, double nu, double stepmin) {
    return OptimiserControllerJNI.OptimiseNLC1(n, x, y, z, m, Bar_Ab, Bar_U, Bar_Grad, Bar_Hess, tol, iter, iprint, rho, theta, nu, stepmin);
  }

  public static short OptimiseNLC_Seq(long n, double[] x, double[] y, double[] z, long m, Object Bar_Ab, Object Bar_U, Object Bar_Grad, Object Bar_Hess, double tol, int[] iter, int iprint, double nu, double[] lower, double[] upper) {
    return OptimiserControllerJNI.OptimiseNLC_Seq(n, x, y, z, m, Bar_Ab, Bar_U, Bar_Grad, Bar_Hess, tol, iter, iprint, nu, lower, upper);
  }

  public static short gramS(long n, double[] Q, double[] basevectors, double[] basevalues, byte[] sparse) {
    return OptimiserControllerJNI.gramS(n, Q, basevectors, basevalues, sparse);
  }

  public static void inverseT(long n, double[] e, double[] basevectors) {
    OptimiserControllerJNI.inverseT(n, e, basevectors);
  }

  public static void solveT(long n, double[] e, double[] x) {
    OptimiserControllerJNI.solveT(n, e, x);
  }

  public static void solveTt(long n, double[] e, double[] x) {
    OptimiserControllerJNI.solveTt(n, e, x);
  }

  public static void multT(long n, double[] e, double[] x) {
    OptimiserControllerJNI.multT(n, e, x);
  }

  public static void multTt(long n, double[] e, double[] x) {
    OptimiserControllerJNI.multTt(n, e, x);
  }

  public static boolean FixGram(long n, double[] QFIX) {
    return OptimiserControllerJNI.FixGram(n, QFIX);
  }

  public static long Arnoldi(long n, double[] A, double[] q, double[] H, int transpose) {
    return OptimiserControllerJNI.Arnoldi(n, A, q, H, transpose);
  }

  public static void pattern6(long n, double[] w_opt, double[] f, double[] g, double[] hess, Object calcfx, double[] w, double dfn, double[] xm, double hh, double eps, long mode, long maxfn, long iprint, int[] iexit, int repeat) {
    OptimiserControllerJNI.pattern6(n, w_opt, f, g, hess, calcfx, w, dfn, xm, hh, eps, mode, maxfn, iprint, iexit, repeat);
  }

  public static void setunitHess(long n, double[] H) {
    OptimiserControllerJNI.setunitHess(n, H);
  }

  public static long findzero(long n, double[] w) {
    return OptimiserControllerJNI.findzero(n, w);
  }

  public static boolean parity_check(long n, int nfac, double[] w, double[] alpha, double[] Q, double[] FL, double[] FC, double[] SV, long nsect, double[] sectors) {
    return OptimiserControllerJNI.parity_check(n, nfac, w, alpha, Q, FL, FC, SV, nsect, sectors);
  }

  public static short OptimiseNLCAL(long n, double[] w, long m, double[] A, long mAL, Object Bar_Ab, Object Bar_U, Object Bar_Grad, Object Bar_Hess, double[] L, double[] U) {
    return OptimiserControllerJNI.OptimiseNLCAL(n, w, m, A, mAL, Bar_Ab, Bar_U, Bar_Grad, Bar_Hess, L, U);
  }

  public static short QuasiNewton(long n, double[] w_opt, int print, long maxiter, double[] f, Object calcfx, double conv, int updatemethod, int twosided, double stoplimit) {
    return OptimiserControllerJNI.QuasiNewton(n, w_opt, print, maxiter, f, calcfx, conv, updatemethod, twosided, stoplimit);
  }

  public static long multistage(long n, long y, double[] wfinal, double[] wbefore, double[] wrebalanced, double[] mrisks, double[] Growth, double[] Yield, double[] Liability, double[] lbound, double[] ubound, String[] stocknames, double[] Q, double[] first, double delta, double maxrisk, long[] NumberYears, long meth, long print) {
    return OptimiserControllerJNI.multistage(n, y, wfinal, wbefore, wrebalanced, mrisks, Growth, Yield, Liability, lbound, ubound, stocknames, Q, first, delta, maxrisk, NumberYears, meth, print);
  }

  public static String BasicQpOpt(long n, long m, double[] AA, double[] LL, double[] UU, double[] w_opt, double[] CC, double[] HH, short lp, Object Hmul, int fixn, long ncomp, double[] CComposites, int nfac, double[] SSV, double[] FFL, long LS, long Full, long npiece, double[] ccostdata, Object util, Object modderiv, Object modhessian) {
    return OptimiserControllerJNI.BasicQpOpt(n, m, AA, LL, UU, w_opt, CC, HH, lp, Hmul, fixn, ncomp, CComposites, nfac, SSV, FFL, LS, Full, npiece, ccostdata, util, modderiv, modhessian);
  }

  public static void simplex(long n, double[] start, double[] w_opt, double[] ynewlow, double reqmin, double[] step, long konvge, long kcount, long[] icount, long[] numres, long[] ifault, Object simpfunc) {
    OptimiserControllerJNI.simplex(n, start, w_opt, ynewlow, reqmin, step, konvge, kcount, icount, numres, ifault, simpfunc);
  }

  public static void factor_model_process(long n, long nfac, double[][] FLOAD, double[] FFC, double[] SSV, double[] QMATRIX) {
    OptimiserControllerJNI.factor_model_process(n, nfac, FLOAD, FFC, SSV, QMATRIX);
  }

  public static void apt_model_process(long n, long nfac, double[][] FLOAD, double[] eigval, double[] SSV, double[] QMATRIX) {
    OptimiserControllerJNI.apt_model_process(n, nfac, FLOAD, eigval, SSV, QMATRIX);
  }

  public static void NaiveRound(long n, double[] w, double[] Initial, double[] minlot, double[] sizelot, double[] roundw) {
    OptimiserControllerJNI.NaiveRound(n, w, Initial, minlot, sizelot, roundw);
  }

  public static double Solve1D(Object RiskE, double gammabot, double gammatop, double tol) {
    return OptimiserControllerJNI.Solve1D(RiskE, gammabot, gammatop, tol);
  }

  public static double PathMin(Object RiskE, double gammabot, double gammatop, double tol, int stopifpos) {
    return OptimiserControllerJNI.PathMin(RiskE, gammabot, gammatop, tol, stopifpos);
  }

  public static void dmx_transpose(long n, long m, double[] a, double[] transposed) {
    OptimiserControllerJNI.dmx_transpose(n, m, a, transposed);
  }

  public static long get_nfac(String name) {
    return OptimiserControllerJNI.get_nfac(name);
  }

  public static void getdata(long nstocks, long nfac, String[] namelist, double[][] FLOUT, double[] SVOUT, double[] FCOUT, String name) {
    OptimiserControllerJNI.getdata(nstocks, nfac, namelist, FLOUT, SVOUT, FCOUT, name);
  }

  public static void get_stocknames(String[] sname, String name) {
    OptimiserControllerJNI.get_stocknames(sname, name);
  }

  public static long get_nstocks(String name) {
    return OptimiserControllerJNI.get_nstocks(name);
  }

  public static void get_factornames(String[] fname, String name) {
    OptimiserControllerJNI.get_factornames(fname, name);
  }

  public static short conj_solve(long n, double[] M, double[] y, double[] w_opt, long ndiag, Object conjmul, int usediag, int log) {
    return OptimiserControllerJNI.conj_solve(n, M, y, w_opt, ndiag, conjmul, usediag, log);
  }

  public static short Optimise_internalCVP(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad) {
    return OptimiserControllerJNI.Optimise_internalCVP(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad);
  }

  public static short Optimise_internalCVPAextcosts(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double kappa, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object piece_cost, Object piece_grad, Object piece_q, double minRisk, double maxRisk, double[] ogamma, short take_out_costs, double[] mask, int log, String logfile, short ExtraIt, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale) {
    return OptimiserControllerJNI.Optimise_internalCVPAextcosts(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, piece_cost, piece_grad, piece_q, minRisk, maxRisk, ogamma, take_out_costs, mask, log, logfile, ExtraIt, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale);
  }

  public static short Optimise_internalCVPAextcostsl(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double kappa, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object piece_cost, Object piece_grad, Object piece_q, double minRisk, double maxRisk, double[] ogamma, short take_out_costs, double[] mask, int log, String logfile, short ExtraIt, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.Optimise_internalCVPAextcostsl(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, piece_cost, piece_grad, piece_q, minRisk, maxRisk, ogamma, take_out_costs, mask, log, logfile, ExtraIt, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L);
  }

  public static short Optimise_internalCVPAextcostslSa(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double kappa, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object piece_cost, Object piece_grad, Object piece_q, double minRisk, double maxRisk, double[] ogamma, short take_out_costs, double[] mask, int log, String logfile, short ExtraIt, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost) {
    return OptimiserControllerJNI.Optimise_internalCVPAextcostslSa(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, piece_cost, piece_grad, piece_q, minRisk, maxRisk, ogamma, take_out_costs, mask, log, logfile, ExtraIt, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost);
  }

  public static short Optimise_internalCVPAextcostslSaM(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double kappa, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object piece_cost, Object piece_grad, Object piece_q, double minRisk, double maxRisk, double[] ogamma, short take_out_costs, double[] mask, int log, String logfile, short ExtraIt, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes) {
    return OptimiserControllerJNI.Optimise_internalCVPAextcostslSaM(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, piece_cost, piece_grad, piece_q, minRisk, maxRisk, ogamma, take_out_costs, mask, log, logfile, ExtraIt, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes);
  }

  public static short Optimise_internalCVPAextcostslSaMS(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double kappa, int basket, int trades, int revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object piece_cost, Object piece_grad, Object piece_q, double minRisk, double maxRisk, double[] ogamma, short take_out_costs, double[] mask, int log, String logfile, short ExtraIt, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes, long softm, double errorBound) {
    return OptimiserControllerJNI.Optimise_internalCVPAextcostslSaMS(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, piece_cost, piece_grad, piece_q, minRisk, maxRisk, ogamma, take_out_costs, mask, log, logfile, ExtraIt, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes, softm, errorBound);
  }

  public static short Optimise_internalCVPAextcostslSaMSoft(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double kappa, int basket, int trades, int revise, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object piece_cost, Object piece_grad, Object piece_q, double minRisk, double maxRisk, double[] ogamma, short take_out_costs, double[] mask, int log, String logfile, short ExtraIt, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes, long soft_m, double[] soft_l, double[] soft_b, double[] soft_L, double[] soft_U, double[] soft_A, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.Optimise_internalCVPAextcostslSaMSoft(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, piece_cost, piece_grad, piece_q, minRisk, maxRisk, ogamma, take_out_costs, mask, log, logfile, ExtraIt, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes, soft_m, soft_l, soft_b, soft_L, soft_U, soft_A, five, ten, forty, issues);
  }

  public static short Optimise_internalCVPA(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] mask, int log, String logfile) {
    return OptimiserControllerJNI.Optimise_internalCVPA(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, mask, log, logfile);
  }

  public static short Optimise_internalCVPAF(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor) {
    return OptimiserControllerJNI.Optimise_internalCVPAF(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor);
  }

  public static short Optimise_internalCVPAFb(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale) {
    return OptimiserControllerJNI.Optimise_internalCVPAFb(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale);
  }

  public static short Optimise_internalCVPAFbl(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.Optimise_internalCVPAFbl(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L);
  }

  public static short Optimise_internalCVPAFblQ(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] qbuy, double[] qsell) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblQ(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, qbuy, qsell);
  }

  public static short Optimise_internalCVPAFblSa(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblSa(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost);
  }

  public static short Optimise_internalCVPAFblSaM(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblSaM(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes);
  }

  public static short Optimise_internalCVPAFblSaMS(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes, long softm, double errorBound) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblSaMS(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes, softm, errorBound);
  }

  public static short Optimise_internalCVPAFblSaMSoft(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes, long soft_m, double[] soft_l, double[] soft_b, double[] soft_L, double[] soft_U, double[] soft_A) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblSaMSoft(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes, soft_m, soft_l, soft_b, soft_L, soft_U, soft_A);
  }

  public static short Optimise_internalCVPAFblSaMSoftQ(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes, long soft_m, double[] soft_l, double[] soft_b, double[] soft_L, double[] soft_U, double[] soft_A, double[] qbuy, double[] qsell, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblSaMSoftQ(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes, soft_m, soft_l, soft_b, soft_L, soft_U, soft_A, qbuy, qsell, five, ten, forty, issues);
  }

  public static short Optimise_internalCVPAFblSaMSoftQV(long n, int nfac, String[] stocknames, double[] w_opt, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIX, double gamma, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, int revise, int costs, double[] min_holding, double[] min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] shake, long ncomp, double[] Composite, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double minRisk, double maxRisk, double[] ogamma, double[] mask, int log, String logfile, int downrisk, double downfactor, int longbasket, int shortbasket, int tradebuy, int tradesell, double zetaS, double zetaF, double ShortCostScale, double LSValuel, double[] Abs_L, double[] shortalphacost, int never_slow, long[] mem_kbytes, long soft_m, double[] soft_l, double[] soft_b, double[] soft_L, double[] soft_U, double[] soft_A, double[] qbuy, double[] qsell, double five, double ten, double forty, int[] issues) {
    return OptimiserControllerJNI.Optimise_internalCVPAFblSaMSoftQV(n, nfac, stocknames, w_opt, m, AAA, L, U, alpha, benchmark, QMATRIX, gamma, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, shake, ncomp, Composite, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, minRisk, maxRisk, ogamma, mask, log, logfile, downrisk, downfactor, longbasket, shortbasket, tradebuy, tradesell, zetaS, zetaF, ShortCostScale, LSValuel, Abs_L, shortalphacost, never_slow, mem_kbytes, soft_m, soft_l, soft_b, soft_L, soft_U, soft_A, qbuy, qsell, five, ten, forty, issues);
  }

  public static short FrontierCVPA(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, long revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] mask) {
    return OptimiserControllerJNI.FrontierCVPA(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, mask);
  }

  public static short FrontierCVPAF(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, long revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double[] mask, int DoByRisks) {
    return OptimiserControllerJNI.FrontierCVPAF(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, mask, DoByRisks);
  }

  public static short FrontierCVPAFb(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, long revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double[] mask, int DoByRisks, int longbasket, int shortbasket, int tradebuy, int tradesell, double ShortCostScale) {
    return OptimiserControllerJNI.FrontierCVPAFb(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, mask, DoByRisks, longbasket, shortbasket, tradebuy, tradesell, ShortCostScale);
  }

  public static short FrontierCVPAFbl(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, long revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double[] mask, int DoByRisks, int longbasket, int shortbasket, int tradebuy, int tradesell, double ShortCostScale, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.FrontierCVPAFbl(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, mask, DoByRisks, longbasket, shortbasket, tradebuy, tradesell, ShortCostScale, LSValuel, Abs_L);
  }

  public static short FrontierCVPAFblQ(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, long revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long npiece, double[] hpiece, double[] pgrad, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, double[] mask, int DoByRisks, int longbasket, int shortbasket, int tradebuy, int tradesell, double ShortCostScale, double LSValuel, double[] Abs_L, double[] qbuy, double[] qsell) {
    return OptimiserControllerJNI.FrontierCVPAFblQ(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, npiece, hpiece, pgrad, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, mask, DoByRisks, longbasket, shortbasket, tradebuy, tradesell, ShortCostScale, LSValuel, Abs_L, qbuy, qsell);
  }

  public static short FrontierCVPF(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double[] buy, double[] sell, double kappa, int basket, int trades, long revise, int costs, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long npiece, double[] hpiece, double[] pgrad, double[] FFC, double[][] FLOAD, double[] SSV, double[] mask, int DoByRisks) {
    return OptimiserControllerJNI.FrontierCVPF(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, buy, sell, kappa, basket, trades, revise, costs, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, npiece, hpiece, pgrad, FFC, FLOAD, SSV, mask, DoByRisks);
  }

  public static short FrontierCVPAextcosts(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double kappa, int basket, int trades, long revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object frontpiece_cost, Object frontpiece_grad, Object frontpiece_q, short take_out_costs, double[] mask, short ExtraIt, int DoByRisks, int longbasket, int shortbasket, int tradebuy, int tradesell, double ShortCostScale) {
    return OptimiserControllerJNI.FrontierCVPAextcosts(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, frontpiece_cost, frontpiece_grad, frontpiece_q, take_out_costs, mask, ExtraIt, DoByRisks, longbasket, shortbasket, tradebuy, tradesell, ShortCostScale);
  }

  public static short FrontierCVPAextcostsl(long npoints, double[] frontrisk, double[] frontarisk, double[] frontrreturn, double[] frontareturn, long n, int nfac, String[] stocknames, double[] frontw, long m, double[][] AAA, double[] L, double[] U, double[] alpha, double[] benchmark, double[] QMATRIXF, double[] Initial, double delta, double kappa, int basket, int trades, long revise, double min_holding, double min_trade, int m_LS, int Fully_Invested, double Rmin, double Rmax, int m_Round, double[] min_lot, double[] size_lot, int[] frontshake, long ncomp, double[] Comp, double LSValue, long nabs, double[][] Abs_A, long mabs, long[] I_A, double[] Abs_U, double[] FFC, double[][] FLOAD, double[] SSV, Object frontpiece_cost, Object frontpiece_grad, Object frontpiece_q, short take_out_costs, double[] mask, short ExtraIt, int DoByRisks, int longbasket, int shortbasket, int tradebuy, int tradesell, double ShortCostScale, double LSValuel, double[] Abs_L) {
    return OptimiserControllerJNI.FrontierCVPAextcostsl(npoints, frontrisk, frontarisk, frontrreturn, frontareturn, n, nfac, stocknames, frontw, m, AAA, L, U, alpha, benchmark, QMATRIXF, Initial, delta, kappa, basket, trades, revise, min_holding, min_trade, m_LS, Fully_Invested, Rmin, Rmax, m_Round, min_lot, size_lot, frontshake, ncomp, Comp, LSValue, nabs, Abs_A, mabs, I_A, Abs_U, FFC, FLOAD, SSV, frontpiece_cost, frontpiece_grad, frontpiece_q, take_out_costs, mask, ExtraIt, DoByRisks, longbasket, shortbasket, tradebuy, tradesell, ShortCostScale, LSValuel, Abs_L);
  }

  public static void PropertiesC(long n, int nfac, String[] stocknames, double[] w, double[] alpha, double[] benchmark, double[] QMATRIX, double[] risk, double[] arisk, double[] Rrisk, double[] rreturn, double[] areturn, double[] Rreturn, double[] MCAR, double[] MCTR, double[] MCRR, double[] FMCRR, double[] FMCTR, double[] bbeta, double[] FX, double[] RFX, double[][] FLOAD, double[] FFC, double[] SSV, long ncomp, double[] Composite) {
    OptimiserControllerJNI.PropertiesC(n, nfac, stocknames, w, alpha, benchmark, QMATRIX, risk, arisk, Rrisk, rreturn, areturn, Rreturn, MCAR, MCTR, MCRR, FMCRR, FMCTR, bbeta, FX, RFX, FLOAD, FFC, SSV, ncomp, Composite);
  }

  public static void PropertiesCA(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] alpha, double[] rreturn, double[] areturn, double[] Rreturn, double[] breturn, double[] QMATRIX, double[] risk, double[] arisk, double[] Rrisk, double[] brisk, double[] srisk, double[] pbeta, double[] MCAR, double[] MCTR, double[] MCRR, double[] MCBR, double[] FMCRR, double[] FMCTR, double[] FMCAR, double[] FMCBR, double[] FMCSR, double[] beta, double[] FX, double[] RFX, double[] AFX, double[] BFX, double[] SFX, double[][] FLOAD, double[] FFC, double[] SSV, long ncomp, double[] Composite) {
    OptimiserControllerJNI.PropertiesCA(n, nfac, stocknames, w, benchmark, alpha, rreturn, areturn, Rreturn, breturn, QMATRIX, risk, arisk, Rrisk, brisk, srisk, pbeta, MCAR, MCTR, MCRR, MCBR, FMCRR, FMCTR, FMCAR, FMCBR, FMCSR, beta, FX, RFX, AFX, BFX, SFX, FLOAD, FFC, SSV, ncomp, Composite);
  }

  public static void GetBeta(long n, int nfac, double[] benchmark, double[] Q, double[] beta, long ncomp, double[] Composite) {
    OptimiserControllerJNI.GetBeta(n, nfac, benchmark, Q, beta, ncomp, Composite);
  }

  public static void Get_RisksC(long n, int nfac, double[] Q, double[] w, double[] benchmark, double[] arisk, double[] risk, double[] Rrisk, double[] brisk, double[] pbeta, long ncomp, double[] Composite) {
    OptimiserControllerJNI.Get_RisksC(n, nfac, Q, w, benchmark, arisk, risk, Rrisk, brisk, pbeta, ncomp, Composite);
  }

  public static void MarginalUtility(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] Initial, double[] Q, double gamma, double kappa, long npiece, double[] hpiece, double[] pgrad, double[] buy, double[] sell, double[] alpha, double[] tcost, double[] utility, double[] gradutility, double[] utility_per_stock, double[] cost_per_stock, long ncomp, double[] Composite) {
    OptimiserControllerJNI.MarginalUtility(n, nfac, stocknames, w, benchmark, Initial, Q, gamma, kappa, npiece, hpiece, pgrad, buy, sell, alpha, tcost, utility, gradutility, utility_per_stock, cost_per_stock, ncomp, Composite);
  }

  public static void MarginalUtilityb(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] Initial, double[] Q, double gamma, double kappa, long npiece, double[] hpiece, double[] pgrad, double[] buy, double[] sell, double[] alpha, double[] tcost, double[] utility, double[] gradutility, double[] utility_per_stock, double[] cost_per_stock, long ncomp, double[] Composite, double ShortCostScale) {
    OptimiserControllerJNI.MarginalUtilityb(n, nfac, stocknames, w, benchmark, Initial, Q, gamma, kappa, npiece, hpiece, pgrad, buy, sell, alpha, tcost, utility, gradutility, utility_per_stock, cost_per_stock, ncomp, Composite, ShortCostScale);
  }

  public static void MarginalUtilitybSa(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] Initial, double[] Q, double gamma, double kappa, long npiece, double[] hpiece, double[] pgrad, double[] buy, double[] sell, double[] alpha, double[] tcost, double[] utility, double[] gradutility, double[] utility_per_stock, double[] cost_per_stock, long ncomp, double[] Composite, double ShortCostScale, double[] shortalphacost) {
    OptimiserControllerJNI.MarginalUtilitybSa(n, nfac, stocknames, w, benchmark, Initial, Q, gamma, kappa, npiece, hpiece, pgrad, buy, sell, alpha, tcost, utility, gradutility, utility_per_stock, cost_per_stock, ncomp, Composite, ShortCostScale, shortalphacost);
  }

  public static void MarginalUtilitybSaQ(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] Initial, double[] Q, double gamma, double kappa, long npiece, double[] hpiece, double[] pgrad, double[] buy, double[] sell, double[] alpha, double[] tcost, double[] utility, double[] gradutility, double[] utility_per_stock, double[] cost_per_stock, long ncomp, double[] Composite, double ShortCostScale, double[] shortalphacost, double[] qbuy, double[] qsell) {
    OptimiserControllerJNI.MarginalUtilitybSaQ(n, nfac, stocknames, w, benchmark, Initial, Q, gamma, kappa, npiece, hpiece, pgrad, buy, sell, alpha, tcost, utility, gradutility, utility_per_stock, cost_per_stock, ncomp, Composite, ShortCostScale, shortalphacost, qbuy, qsell);
  }

  public static void MarginalUtility_ext(long n, int nfac, String[] stocknames, double[] w, double[] benchmark, double[] initial, double[] Q, double gamma, double kappa, double[] alpha, double[] tcost, double[] utility, double[] gradutility, long ncomp, double[] Composite, double ShortCostScale, Object margUtil, Object margModDeriv, double[] shortalphacost) {
    OptimiserControllerJNI.MarginalUtility_ext(n, nfac, stocknames, w, benchmark, initial, Q, gamma, kappa, alpha, tcost, utility, gradutility, ncomp, Composite, ShortCostScale, margUtil, margModDeriv, shortalphacost);
  }

  public static double round_weight(double x, double initial, double minl, double sizel, double minl1) {
    return OptimiserControllerJNI.round_weight(x, initial, minl, sizel, minl1);
  }

  public static void dsmxmulv(long n, double[] S, double[] x, double[] w_opt) {
    OptimiserControllerJNI.dsmxmulv(n, S, x, w_opt);
  }

  public static void dsmxmulvT(long n, double[] S, double[] x, double[] w_opt) {
    OptimiserControllerJNI.dsmxmulvT(n, S, x, w_opt);
  }

  public static short OptAdvanced(long n, long m, double[] w_opt, double[][] AAA, double[] L, double[] U, double[] c, double[] multip, Object Qwmul, double[] Q) {
    return OptimiserControllerJNI.OptAdvanced(n, m, w_opt, AAA, L, U, c, multip, Qwmul, Q);
  }

}
